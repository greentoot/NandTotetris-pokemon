class Battle {
    field Pokemon playerPokemon;
    field Pokemon enemyPokemon;
    field Pokedex pokedex;
    field Team playerTeam;
    field Team enemyTeam;  // ✅ AJOUTÉ
    field int selectedMove;
    field boolean inSwitchMenu;
    field int switchSelectedIndex;
    field Inventory inventory;
    
    constructor Battle new(Pokemon player, Pokemon enemy, Pokedex dex, Team team, Inventory inv) {
        let playerPokemon = player;
        let enemyPokemon = enemy;
        let pokedex = dex;
        let playerTeam = team;
        let enemyTeam = null;  //  AJOUTÉ - sera null pour Pokémon sauvages
        let selectedMove = 0;
        let inSwitchMenu = false;
        let switchSelectedIndex = 0;
        let inventory = inv;
        return this;
    }
    
    //  AJOUTÉ - Méthode pour définir l'équipe ennemie (dresseurs)
    method void setEnemyTeam(Team team) {
        let enemyTeam = team;
        return;
    }
    
method void drawSwitchMenu() {
    var int i, count, displayRow;
    var Pokemon poke;
    
    // Effacer la zone des attaques
    do Screen.setColor(false);
    do Screen.drawRectangle(0, 152, 511, 255);
    
    // Titre
    do Output.moveCursor(19, 2);
    do Strings.printChoisirPokemon();
    
    let count = playerTeam.getCount();
    let i = 0;
    let displayRow = 0;
    
    while (i < count) {
        let poke = playerTeam.getPokemon(i);
        
        // Ne pas afficher le Pokémon actuel
        if (~(poke = playerPokemon)) {
            // Limiter à 3 lignes maximum (rows 20, 21, 22)
            if (displayRow < 3) {
                do Output.moveCursor(20 + displayRow, 2);
                
                // Indicateur de sélection
                if (i = switchSelectedIndex) {
                    do Output.printChar(62); // >
                } else {
                    do Output.printChar(32); // espace
                }
                
                do Output.printInt(i + 1);
                do Output.printChar(46); // .
                do Output.printChar(32); // espace
                do Strings.printPokemonName(poke.getType());
                do Output.printChar(32); // espace
                do Strings.printHP();
                do Output.printInt(poke.getHp());
                do Output.printChar(47); // /
                do Output.printInt(poke.getMaxHp());
                
                // Indiquer si KO
                if (poke.isFainted()) {
                    do Output.printChar(32); // espace
                    do Output.printChar(91); // [
                    do Output.printChar(75); // K
                    do Output.printChar(79); // O
                    do Output.printChar(93); // ]
                }
                
                let displayRow = displayRow + 1;
            }
        }
        
        let i = i + 1;
    }
    
    // Message de retour sur la dernière ligne disponible
    if (displayRow < 3) {
        do Output.moveCursor(20 + displayRow, 35);
    } else {
        do Output.moveCursor(22, 35);
    }
    do Strings.printRetour();
    
    return;
}
    
    method boolean isInSwitchMenu() {
        return inSwitchMenu;
    }
    method boolean hasStab(int pokemonType, int moveType) {
    // SalamÃ¨che (0) -> Feu (1)
    if ((pokemonType = 0) & (moveType = 1)) { return true; }
    
    // Carapuce (1) -> Eau (2)
    if ((pokemonType = 1) & (moveType = 2)) { return true; }
    
    // Bulbizarre (2) -> Plante (3)
    if ((pokemonType = 2) & (moveType = 3)) { return true; }
    
    // Pikachu (3) -> Ã‰lectrique (4)
    if ((pokemonType = 3) & (moveType = 4)) { return true; }
    
    // Roucool (4) -> Vol (5)
    if ((pokemonType = 4) & (moveType = 5)) { return true; }
    
    // Abra (5) -> Psy (6)
    if ((pokemonType = 5) & (moveType = 6)) { return true; }

    if ((pokemonType = 6) & (moveType = 0)) { return true; } // Rattata -> Normal
    
    // Mystherbe (7) -> Plante (3)
    if ((pokemonType = 7) & (moveType = 3)) { return true; }
    
    // Sabelette (8) -> Sol (7)
    if ((pokemonType = 8) & (moveType = 7)) { return true; }
    
    // Stari (9) -> Eau (2)
    if ((pokemonType = 9) & (moveType = 2)) { return true; }

    
    return false;
}

    method void setInSwitchMenu(boolean value) {
        let inSwitchMenu = value;
        return;
    }

    method int getSwitchSelectedIndex() {
        return switchSelectedIndex;
    }
    
    method int switchPokemon(int newIndex) {
        var Pokemon newPoke;
        var int enemyDamage;
        var Move move;
        
        let newPoke = playerTeam.getPokemon(newIndex);
        
        // VÃ©rifier que le PokÃ©mon n'est pas KO
        if (newPoke.isFainted()) {
            do Output.moveCursor(18, 0);
            do Strings.printPokemonKO();
            do Sys.wait(1500);
            return 0;
        }
        
        // VÃ©rifier que ce n'est pas le PokÃ©mon actuel
        if (newPoke = playerPokemon) {
            do Output.moveCursor(18, 0);
            do Strings.printDejaActif();
            do Sys.wait(1500);
            return 0;
        }
        
        // Fermer le menu AVANT le switch
        let inSwitchMenu = false;
        
        // Effectuer le switch
        do playerTeam.setActive(newIndex);
        let playerPokemon = newPoke;
        
        do Output.moveCursor(18, 0);
        do Strings.printReviens();
        do Sys.wait(1000);
        
        // L'ennemi attaque pendant le switch
        let move = enemyPokemon.getMove(Random.randRange(0, enemyPokemon.getMoveCount() - 1));
        let enemyDamage = calculateDamage(enemyPokemon, playerPokemon, move);
        do playerPokemon.takeDamage(enemyDamage);
        
        do Output.moveCursor(18, 0);
        do Strings.printEnnemiInflige();
        do Output.printInt(enemyDamage);
        do Strings.printDegats();
        do Sys.wait(1500);
        
        if (playerPokemon.isFainted()) {
            return 2; // DÃ©faite si le nouveau PokÃ©mon est KO
        }
        
        return 0; // Combat continue
    }
    
    method void moveSwitchSelection(int direction) {
        var int count;
        let count = playerTeam.getCount();
        
        let switchSelectedIndex = switchSelectedIndex + direction;
        
        if (switchSelectedIndex < 0) {
            let switchSelectedIndex = 0;
        }
        if (switchSelectedIndex > (count - 1)) {
            let switchSelectedIndex = count - 1;
        }
        
        return;
    }
    
    method void draw() {
        do Screen.clearScreen();
        
        // Pokemon ennemi (en haut Ã  droite)
        do drawEnemyPokemon(370, 50);
        
        // Pokemon du joueur (en bas Ã  gauche)
        do drawPlayerPokemon(80, 120);
        
        // Info combat
        do drawBattleInfo();
        
        return;
    }
    
    method void drawEnemyPokemon(int x, int y) {
        var int type;
        let type = enemyPokemon.getType();
        
        // Dessiner le sprite du Pokemon selon son type
        do drawPokemonSprite(x, y, type, false);
        
        // Nom et niveau
        do Output.moveCursor(1, 40);
        do printPokemonName(type);
        do Strings.printNv();
        do Output.printInt(enemyPokemon.getLevel());
        if (enemyPokemon.getLevel()> 50){
             do drawHpBar(x - 30, y + 50, 35, 35);

        }
        // Barre de vie
        else {
        do drawHpBar(x - 30, y + 50, enemyPokemon.getHp(), enemyPokemon.getMaxHp());
        }
        return;
    }
    
    method void drawPlayerPokemon(int x, int y) {
        var int type;
        let type = playerPokemon.getType();
        
        // Dessiner le sprite du Pokemon (dos)

        do drawPokemonSprite(x, y, type, true);

        // Nom et niveau
        do Output.moveCursor(14, 1);
        do printPokemonName(type);
        do Strings.printNv();
        do Output.printInt(playerPokemon.getLevel());
        if (playerPokemon.getLevel()> 50){
             do drawHpBar(x - 30, y + 50, 35, 35);

        }
        else {do drawHpBar(x + 80, y + 20, playerPokemon.getHp(), playerPokemon.getMaxHp());}
        
        return;
    }
    
    method void drawPokemonSprite(int x, int y, int type, boolean isPlayer) {
        do Sprites.drawPokemon(x, y, type);
        return;
    }
    
    method void drawHpBar(int x, int y, int currentHp, int maxHp) {
        var int barWidth, hpWidth;
        let barWidth = 60;
    if (maxHp < 1) {
        let maxHp = 1;  // Valeur minimum
    }
        let hpWidth = (currentHp * barWidth) / maxHp;
        
        do Output.moveCursor(y / 11, x / 8);
        do Strings.printHP();
        
        // Contour
        do Screen.setColor(true);
        do Screen.drawRectangle(x + 20, y, x + 20 + barWidth, y + 4);
        
        // HP restants
        do Screen.setColor(false);
        do Screen.drawRectangle(x + 21, y + 1, x + 19 + barWidth, y + 3);
        do Screen.setColor(true);
        if (hpWidth > 0) {
            do Screen.drawRectangle(x + 21, y + 1, x + 20 + hpWidth, y + 3);
        }
        
        return;
    }
    
    method void drawBattleInfo() {
        var int i, moveCount;
        var Move move;
        
        // Menu d'attaques
        do Output.moveCursor(19, 0);
        do Strings.printChoisissezAttaque();
        
        let moveCount = playerPokemon.getMoveCount();
        let i = 0;
        while (i < moveCount) {
            let move = playerPokemon.getMove(i);
            do Output.moveCursor(20 + i, 2);
            do Output.printInt(i + 1);
            do Output.printChar(46); // .
            do Output.printChar(32); // espace
            do printMoveName(move.getId());
            do Output.printChar(32); // espace
            do Output.printChar(40); // (
            do Output.printInt(move.getPower());
            do Output.printChar(41); // )
            let i = i + 1;
        }
        
        do Output.moveCursor(20, 35);
        do Strings.printCapturer();
        do Output.moveCursor(21, 35);
        do Output.printChar(40);  // (
        do Output.printChar(73);  // I
        do Output.printChar(41);  // )
        do Output.printChar(32);  // espace
        do Strings.printInventaire();
        do Output.moveCursor(22, 35);
        do Strings.printFuir();
        
        return;
    }
    
    method void printPokemonName(int type) {
        if (type = 0) { do Strings.printSalameche(); }
        if (type = 1) { do Strings.printCarapuce(); }
        if (type = 2) { do Strings.printBulbizarre(); }
        if (type = 3) { do Strings.printPikachu(); }
        if (type = 4) { do Strings.printRoucool(); }
        if (type = 5) { do Strings.printRattata(); }
        if (type =6) { do Strings.printSabelette(); }
        if (type = 7) { do Strings.printStari(); }
        if (type = 8) { do Strings.printArcanin(); }
        if (type = 9) { do Strings.printTaupiqueur();}
        if (type = 10) { do Strings.printTriopikeur(); }
        if (type = 11) {do Strings.printNoadkoko();} 

        return;
    }

    method void printMoveName(int moveId) {
        if (moveId = 0) { do Strings.printGriffe(); }
        if (moveId = 1) { do Strings.printFlammeche(); }
        if (moveId = 2) { do Strings.printCharge(); }
        if (moveId = 3) { do Strings.printPistoletO(); }
        if (moveId = 4) { do Strings.printCharge(); }
        if (moveId = 5) { do Strings.printFouetLianes(); }
        if (moveId = 6) { do Strings.printViveAttaque(); }
        if (moveId = 7) { do Strings.printEclair(); }
        if (moveId = 8) { do Strings.printPicpic(); }
        if (moveId = 9) { do Strings.printCruAile(); }
        if (moveId = 10) { do Strings.printTeleport(); }
        if (moveId = 11) { do Strings.printChocMental(); }
        if (moveId = 12) { do Strings.printCrocDeMort(); }
        if (moveId = 13) { do Strings.printPoudreDodo(); }
        if (moveId = 14) { do Strings.printSeisme(); }
        if (moveId = 15) { do Strings.printHydrocanon(); }
        return;
    }
method int attack(int moveIndex) {
    var Move move;
    var int damage, enemyDamage, effectiveness;// expGained;
    //var boolean leveledUp;
    
    if (moveIndex > (playerPokemon.getMoveCount() - 1)) {
        return 0;
    }
    
    // ===== ATTAQUE DU JOUEUR =====
    let move = playerPokemon.getMove(moveIndex);
    let damage = calculateDamage(playerPokemon, enemyPokemon, move);
    let effectiveness = getEffectiveness(move.getType(), enemyPokemon.getType());
    
    do enemyPokemon.takeDamage(damage);
    
    do Output.moveCursor(18, 0);
    do Strings.printVousInfligez();
    do Output.printInt(damage);
    do Strings.printDegats();
    do Sys.wait(1000);
    
    do Strings.printeffectiveness(effectiveness);
    
    // ===== VÉRIFIER SI ENNEMI KO =====
    if (enemyPokemon.isFainted()) {
        // Gain d'XP
        //let expGained = enemyPokemon.calculateExpYield(enemyPokemon.getLevel());
        //let leveledUp = playerPokemon.gainExp(expGained);
        
        do Output.moveCursor(18, 0);
        do Strings.printPokemonName(enemyPokemon.getType());
        do Output.printChar(32); // espace
        do Strings.printPokemonKO();
        do Sys.wait(2000);

        
        if (~(enemyTeam = null)) {
            if (enemyTeam.hasAlivePokemon()) {
                return switchEnemyPokemon();
            } else {
                return 1; // Victoire
            }
        } else {
            return 1; // Victoire
        }
    }
    
    // ===== ATTAQUE DE L'ENNEMI =====
    let move = enemyPokemon.getMove(Random.randRange(0, enemyPokemon.getMoveCount() - 1));
    let enemyDamage = calculateDamage(enemyPokemon, playerPokemon, move);
    do playerPokemon.takeDamage(enemyDamage);
    
    do Output.moveCursor(18, 0);
    do Strings.printEnnemiInflige();
    do Output.printInt(enemyDamage);
    do Strings.printDegats();
    do Sys.wait(1500);
    
    if (playerPokemon.isFainted()) {
        if (hasAlivePokemon()) {
            return forceSwitchPokemon();
        } else {
            return 2; // Défaite
        }
    }
    
    return 0; // Combat continue
}
// ✅ NOUVELLE MÉTHODE - Change vers le prochain Pokémon du dresseur
method int switchEnemyPokemon() {
    var int i, count;
    var Pokemon nextPoke, oldPokemon;
    
    let oldPokemon = enemyPokemon; // Save reference to old Pokémon
    let count = enemyTeam.getCount();
    let i = 0;
    
    // Find next alive Pokémon
    while (i < count) {
        let nextPoke = enemyTeam.getPokemon(i);
        if (~(nextPoke = null)) {
            if (~nextPoke.isFainted()) {
                do enemyTeam.setActive(i);
                let enemyPokemon = nextPoke;
                
                // Only dispose if it's different and we own it
                if (~(oldPokemon = nextPoke)) {
                    // Don't dispose here - team manages it
                }
                
                do Output.moveCursor(18, 0);
                do Strings.printledresseurenvoie();
                do Strings.printPokemonName(nextPoke.getType());
                do Output.printChar(33);
                do Sys.wait(2000);
                
                do draw();
                return 0;
            }
        }
        let i = i + 1;
    }
    
    return 1;
}


    method boolean hasAlivePokemon() {
    return playerTeam.hasAlivePokemon();
}


    method boolean canBattle(Team team) {
    return team.hasAlivePokemon();
}
method int forceSwitchPokemon() {
    var int i, count;
    var Pokemon poke;
    
    let count = playerTeam.getCount();
    let i = 0;
    
    do Output.moveCursor(18, 0);
    do Strings.printpokemonkoafficherautre();
    do Sys.wait(2000);
    
    // Trouver automatiquement le premier PokÃ©mon vivant
    while (i < count) {
        let poke = playerTeam.getPokemon(i);
        if (~(poke = null)) {
            if (~poke.isFainted()) {
                do playerTeam.setActive(i);
                let playerPokemon = poke;
                
                do Output.moveCursor(18, 0);
                do Strings.printAllez();
                do Strings.printPokemonName(poke.getType());
                do Output.printChar(33); // !
                do Sys.wait(1500);
                
                return 0; // Continue le combat
            }
        }
        let i = i + 1;
    }
    
    // Aucun PokÃ©mon vivant = dÃ©faite
    return 2;
}

 method int attemptCapture() {
        var int captureRate, hpPercent, roll, location, i;
        
        // VÃ©rifier si on a des Pokeballs
        if (~inventory.hasItem(0)) {
            do Output.moveCursor(18, 0);
            do Strings.printPasAssezObjets();
            do Sys.wait(1500);
            return 0;
        }
        
        // Taux de capture basÃ© sur les HP restants
        let hpPercent = (enemyPokemon.getHp() * 100) / enemyPokemon.getMaxHp();
        let captureRate = 100 - hpPercent;
        
        // Bonus si dÃ©jÃ  capturÃ©
        if (pokedex.isCaptured(enemyPokemon.getType())) {
            let captureRate = captureRate + 20;
        }
        
        let roll = Random.randRange(0, 100);
        
        do Output.moveCursor(18, 0);
        do Strings.printLancerPokeball();
        
        // Animation de la Pokeball
        let i = 0;
        while (i < 3) {
            let location = (100 * 32) + 15;
            do Sprites.drawPokeball(location);
            do Sys.wait(300);
            do Screen.setColor(false);
            do Screen.drawRectangle(240, 100, 255, 107);
            do Sys.wait(200);
            let i = i + 1;
        }
        
        if (roll < captureRate) {
            // Utiliser la Pokeball
            do inventory.useItem(0);
            
            do pokedex.capture(enemyPokemon.getType());
            do Output.moveCursor(18, 0);
            do Strings.printPokemonCapture();
            do Sys.wait(2000);
            do playerTeam.addPokemon(enemyPokemon);
            
            return 3; // Capture rÃ©ussie
        } else {
            // Pokeball utilisÃ©e quand mÃªme
            do inventory.useItem(0);
            
            do Output.moveCursor(18, 0);
            do Strings.printPokemonEchappe();
            do Sys.wait(1500);
            
            return doEnemyAttack();
        }
    }
    method int doEnemyAttack() {
        var Move move;
        var int enemyDamage;
        
        let move = enemyPokemon.getMove(Random.randRange(0, enemyPokemon.getMoveCount() - 1));
        let enemyDamage = calculateDamage(enemyPokemon, playerPokemon, move);
        do playerPokemon.takeDamage(enemyDamage);
        
        do Output.moveCursor(18, 0);
        do Strings.printEnnemiInflige();
        do Output.printInt(enemyDamage);
        do Strings.printDegats();
        do Sys.wait(1500);
        
        if (playerPokemon.isFainted()) {
            return 2; // DÃ©faite
        }
        
        return 0; // Combat continue
    }
    
    method int calculateDamage(Pokemon attacker, Pokemon defender, Move move) {
        var int damage, effectiveness, attackStat, defenseStat;
        var int level, power, modifier;
        
        let level = attacker.getLevel();
        let power = move.getPower();
        let attackStat = attacker.getAttack();
        let defenseStat = defender.getDefense();
        
        // Formule PokÃ©mon simplifiÃ©e mais rÃ©aliste :
        // Damage = ((2 * Level / 5 + 2) * Power * Attack / Defense / 50 + 2) * Modifiers
        
        // Calcul de base
        let damage = (2 * level) / 5;
        let damage = damage + 2;
        let damage = (damage * power * attackStat) / defenseStat;
        let damage = damage / 50;
        let damage = damage + 2;
        
        // EfficacitÃ© des types (x0.5, x1, x2)
        let effectiveness = getEffectiveness(move.getType(), defender.getType());
        let damage = (damage * effectiveness) / 10;
        
        // STAB (Same Type Attack Bonus) - bonus de 50% si le type de l'attaque correspond au type du PokÃ©mon
        if (hasStab(attacker.getType(), move.getType())) {
            let damage = (damage * 15) / 10; // x1.5
        }
        
        // Variation alÃ©atoire (85-100%)
        let modifier = 85 + Random.randRange(0, 15);
        let damage = (damage * modifier) / 100;
        
        // DÃ©gÃ¢ts minimum de 1
        if (damage < 1) {
            let damage = 1;
        }
        
        return damage;
    }

    
method int getEffectiveness(int attackType, int defenderType) {
    // Types : 0=Normal, 1=Feu, 2=Eau, 3=Plante, 4=Ã‰lectrique, 5=Vol, 6=Psy, 7=Sol
    
    // ===== FEU (1) =====
    if (attackType = 1) {
        if (defenderType = 3) { return 20; } // Super efficace vs Plante
        if (defenderType = 2) { return 5; }  // Peu efficace vs Eau
        if (defenderType = 1) { return 5; }  // Peu efficace vs Feu
        if (defenderType = 7) { return 5; }  // Peu efficace vs Sol
    }
    
    // ===== EAU (2) =====
    if (attackType = 2) {
        if (defenderType = 1) { return 20; } // Super efficace vs Feu
        if (defenderType = 7) { return 20; } // Super efficace vs Sol
        if (defenderType = 3) { return 5; }  // Peu efficace vs Plante
        if (defenderType = 2) { return 5; }  // Peu efficace vs Eau
    }
    
    // ===== PLANTE (3) =====
    if (attackType = 3) {
        if (defenderType = 2) { return 20; } // Super efficace vs Eau
        if (defenderType = 7) { return 20; } // Super efficace vs Sol
        if (defenderType = 1) { return 5; }  // Peu efficace vs Feu
        if (defenderType = 3) { return 5; }  // Peu efficace vs Plante
        if (defenderType = 5) { return 5; }  // Peu efficace vs Vol
    }
    
    // ===== Ã‰LECTRIQUE (4) =====
    if (attackType = 4) {
        if (defenderType = 2) { return 20; } // Super efficace vs Eau
        if (defenderType = 5) { return 20; } // Super efficace vs Vol
        if (defenderType = 3) { return 5; }  // Peu efficace vs Plante
        if (defenderType = 4) { return 5; }  // Peu efficace vs Ã‰lectrique
        if (defenderType = 7) { return 0; }  // Inefficace vs Sol
    }
    
    // ===== VOL (5) =====
    if (attackType = 5) {
        if (defenderType = 3) { return 20; } // Super efficace vs Plante
        if (defenderType = 4) { return 5; }  // Peu efficace vs Ã‰lectrique
        if (defenderType = 7) { return 5; }  // Peu efficace vs Sol
    }
    
    // ===== PSY (6) =====
    if (attackType = 6) {
        if (defenderType = 6) { return 5; }  // Peu efficace vs Psy
    }
    
    // ===== SOL (7) =====
    if (attackType = 7) {
        if (defenderType = 1) { return 20; } // Super efficace vs Feu
        if (defenderType = 4) { return 20; } // Super efficace vs Ã‰lectrique
        if (defenderType = 3) { return 5; }  // Peu efficace vs Plante
        if (defenderType = 5) { return 0; }  // Inefficace vs Vol
    }
    
    // ===== NORMAL (0) =====
    // Normal est neutre contre tout sauf spectre (pas dans ce jeu)
    
    return 10; // Neutre (x1.0)
}

    
    method void dispose() {
        do enemyPokemon.dispose();
        do Memory.deAlloc(this);
        return;
    }
    
    method void disposeWithoutEnemy() {
        // Ne pas disposer enemyPokemon car il est gÃ©rÃ© par Game
        do Memory.deAlloc(this);
        return;
    }
}